#!/usr/bin/env python3\n\"\"\"\nRuntime Environment Validation for TidyFrame\n\nThis module provides runtime validation checks that can be integrated into\napplication startup to ensure secure configuration before the application runs.\n\"\"\"\n\nimport os\nimport sys\nimport asyncio\nfrom typing import Dict, List, Any, Optional\nfrom urllib.parse import urlparse\nimport structlog\n\ntry:\n    import asyncpg\nexcept ImportError:\n    asyncpg = None\n\ntry:\n    import redis\nexcept ImportError:\n    redis = None\n\n# Import our custom validator\ntry:\n    from .env_validator import EnvironmentValidator, EnvironmentValidationError\nexcept ImportError:\n    # Fallback for standalone usage\n    sys.path.append(os.path.dirname(__file__))\n    from env_validator import EnvironmentValidator, EnvironmentValidationError\n\nlogger = structlog.get_logger()\n\n\nclass RuntimeValidator:\n    \"\"\"\n    Runtime validation checks for TidyFrame application startup.\n    \n    This class performs comprehensive validation of the runtime environment,\n    including connectivity checks, permission verification, and security validation.\n    \"\"\"\n    \n    def __init__(self, environment: str = None):\n        self.environment = environment or os.getenv('ENVIRONMENT', 'development')\n        self.errors: List[str] = []\n        self.warnings: List[str] = []\n        self.is_production = self.environment == 'production'\n        \n    async def validate_all(self) -> Dict[str, Any]:\n        \"\"\"\n        Run all runtime validation checks.\n        \n        Returns:\n            Dict containing validation results\n            \n        Raises:\n            EnvironmentValidationError: If critical validation errors are found\n        \"\"\"\n        logger.info(\"Starting runtime validation\", environment=self.environment)\n        \n        # First run static environment validation\n        try:\n            env_validator = EnvironmentValidator(self.environment)\n            env_results = env_validator.validate_all()\n            \n            # Merge environment validation results\n            self.errors.extend(env_results['errors'])\n            self.warnings.extend(env_results['warnings'])\n        except Exception as e:\n            self.errors.append(f\"Environment validation failed: {str(e)}\")\n        \n        # Run runtime connectivity checks\n        await self._validate_database_connectivity()\n        await self._validate_redis_connectivity()\n        await self._validate_external_services()\n        self._validate_file_system_permissions()\n        self._validate_network_connectivity()\n        self._validate_ssl_certificates()\n        \n        # Production-specific runtime checks\n        if self.is_production:\n            self._validate_production_runtime_requirements()\n        \n        # Compile results\n        results = {\n            'environment': self.environment,\n            'valid': len(self.errors) == 0,\n            'errors': self.errors,\n            'warnings': self.warnings,\n            'runtime_checks': True,\n            'timestamp': self._get_timestamp()\n        }\n        \n        # Log results and potentially raise error\n        if self.errors:\n            logger.error(\n                \"Runtime validation failed\",\n                environment=self.environment,\n                errors=len(self.errors),\n                warnings=len(self.warnings)\n            )\n            if self.is_production:\n                raise EnvironmentValidationError(\n                    f\"Production runtime validation failed with {len(self.errors)} errors\"\n                )\n        else:\n            logger.info(\n                \"Runtime validation passed\",\n                environment=self.environment,\n                warnings=len(self.warnings)\n            )\n            \n        return results\n    \n    async def _validate_database_connectivity(self):\n        \"\"\"Validate database connectivity and permissions.\"\"\"\n        database_url = os.getenv('DATABASE_URL')\n        \n        if not database_url:\n            self.errors.append(\"DATABASE_URL not configured\")\n            return\n        \n        if not asyncpg:\n            self.warnings.append(\"asyncpg not available - skipping database connectivity check\")\n            return\n        \n        try:\n            # Parse database URL\n            parsed = urlparse(database_url)\n            \n            # Test basic connectivity\n            conn = await asyncpg.connect(database_url)\n            \n            # Test basic query\n            result = await conn.fetchval('SELECT version()')\n            logger.info(\"Database connectivity verified\", version=result[:50])\n            \n            # Check database permissions\n            try:\n                # Test if we can create/drop a test table\n                await conn.execute('CREATE TABLE IF NOT EXISTS _runtime_test (id SERIAL PRIMARY KEY)')\n                await conn.execute('DROP TABLE _runtime_test')\n                logger.info(\"Database permissions verified\")\n            except Exception as e:\n                self.warnings.append(f\"Database permissions may be limited: {str(e)}\")\n            \n            await conn.close()\n            \n        except asyncpg.exceptions.InvalidAuthorizationSpecificationError:\n            self.errors.append(\"Database authentication failed - check credentials\")\n        except asyncpg.exceptions.CannotConnectNowError:\n            self.errors.append(\"Database server is not accepting connections\")\n        except Exception as e:\n            self.errors.append(f\"Database connectivity failed: {str(e)}\")\n    \n    async def _validate_redis_connectivity(self):\n        \"\"\"Validate Redis connectivity and configuration.\"\"\"\n        redis_url = os.getenv('REDIS_URL')\n        \n        if not redis_url:\n            self.warnings.append(\"REDIS_URL not configured - Redis features will be disabled\")\n            return\n        \n        if not redis:\n            self.warnings.append(\"redis-py not available - skipping Redis connectivity check\")\n            return\n        \n        try:\n            # Create Redis connection\n            r = redis.from_url(redis_url)\n            \n            # Test basic connectivity\n            await asyncio.get_event_loop().run_in_executor(None, r.ping)\n            logger.info(\"Redis connectivity verified\")\n            \n            # Test basic operations\n            test_key = 'runtime_validation_test'\n            await asyncio.get_event_loop().run_in_executor(\n                None, r.setex, test_key, 10, 'test_value'\n            )\n            value = await asyncio.get_event_loop().run_in_executor(\n                None, r.get, test_key\n            )\n            \n            if value != b'test_value':\n                self.warnings.append(\"Redis read/write operations may not be working correctly\")\n            else:\n                # Clean up test key\n                await asyncio.get_event_loop().run_in_executor(\n                    None, r.delete, test_key\n                )\n                logger.info(\"Redis operations verified\")\n            \n            r.close()\n            \n        except redis.AuthenticationError:\n            self.errors.append(\"Redis authentication failed - check password\")\n        except redis.ConnectionError as e:\n            self.errors.append(f\"Redis connectivity failed: {str(e)}\")\n        except Exception as e:\n            self.errors.append(f\"Redis validation failed: {str(e)}\")\n    \n    async def _validate_external_services(self):\n        \"\"\"Validate external service configurations.\"\"\"\n        import aiohttp\n        \n        # Check Gemini API\n        gemini_key = os.getenv('GEMINI_API_KEY')\n        if gemini_key and not gemini_key.startswith('REPLACE_'):\n            try:\n                # Simple API key format validation\n                if len(gemini_key) < 20:\n                    self.warnings.append(\"GEMINI_API_KEY appears to be too short\")\n                else:\n                    logger.info(\"Gemini API key configured\")\n            except Exception as e:\n                self.warnings.append(f\"Gemini API validation failed: {str(e)}\")\n        elif self.is_production:\n            self.errors.append(\"GEMINI_API_KEY required for production\")\n        \n        # Check Stripe API (basic validation)\n        stripe_key = os.getenv('STRIPE_SECRET_KEY')\n        if stripe_key and not stripe_key.startswith('REPLACE_'):\n            if self.is_production and not stripe_key.startswith('sk_live_'):\n                self.errors.append(\"Production must use Stripe live keys (sk_live_)\")\n            elif not self.is_production and not stripe_key.startswith(('sk_test_', 'sk_live_')):\n                self.warnings.append(\"Stripe key format appears invalid\")\n        \n        # Check email service\n        resend_key = os.getenv('RESEND_API_KEY')\n        if resend_key and not resend_key.startswith('REPLACE_'):\n            if not resend_key.startswith('re_'):\n                self.warnings.append(\"Resend API key format appears invalid\")\n    \n    def _validate_file_system_permissions(self):\n        \"\"\"Validate file system permissions and directories.\"\"\"\n        directories_to_check = [\n            ('UPLOAD_DIR', '/app/backend/uploads', True),\n            ('RESULTS_DIR', '/app/backend/results', True),\n            ('SSL_CERT_PATH', '/etc/letsencrypt/live', False),\n        ]\n        \n        for env_var, default_path, required in directories_to_check:\n            path = os.getenv(env_var, default_path)\n            \n            if not path:\n                if required:\n                    self.errors.append(f\"{env_var} not configured\")\n                continue\n            \n            try:\n                # Check if directory exists\n                if not os.path.exists(path):\n                    if required:\n                        try:\n                            os.makedirs(path, exist_ok=True)\n                            logger.info(f\"Created directory: {path}\")\n                        except Exception as e:\n                            self.errors.append(f\"Cannot create required directory {path}: {str(e)}\")\n                    else:\n                        self.warnings.append(f\"Optional directory does not exist: {path}\")\n                    continue\n                \n                # Check permissions\n                if required:\n                    # Test write permissions\n                    test_file = os.path.join(path, '.runtime_test')\n                    try:\n                        with open(test_file, 'w') as f:\n                            f.write('test')\n                        os.remove(test_file)\n                        logger.info(f\"Directory permissions verified: {path}\")\n                    except Exception as e:\n                        self.errors.append(f\"Directory not writable: {path} - {str(e)}\")\n                \n            except Exception as e:\n                self.errors.append(f\"File system validation failed for {path}: {str(e)}\")\n    \n    def _validate_network_connectivity(self):\n        \"\"\"Validate network connectivity requirements.\"\"\"\n        # Check if required ports are available\n        import socket\n        \n        # Check if we can bind to the application port\n        try:\n            port = int(os.getenv('PORT', '8000'))\n            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n            sock.settimeout(1)\n            result = sock.connect_ex(('localhost', port))\n            sock.close()\n            \n            if result == 0:\n                self.warnings.append(f\"Port {port} is already in use\")\n        except Exception as e:\n            self.warnings.append(f\"Port availability check failed: {str(e)}\")\n    \n    def _validate_ssl_certificates(self):\n        \"\"\"Validate SSL certificate configuration.\"\"\"\n        if not self.is_production:\n            return\n        \n        cert_path = os.getenv('SSL_CERT_PATH')\n        key_path = os.getenv('SSL_KEY_PATH')\n        \n        if not cert_path or not key_path:\n            self.warnings.append(\"SSL certificate paths not configured for production\")\n            return\n        \n        try:\n            import ssl\n            import datetime\n            \n            # Check if certificate files exist\n            if not os.path.exists(cert_path):\n                self.errors.append(f\"SSL certificate not found: {cert_path}\")\n                return\n            \n            if not os.path.exists(key_path):\n                self.errors.append(f\"SSL key not found: {key_path}\")\n                return\n            \n            # Check certificate expiry\n            try:\n                import OpenSSL\n                with open(cert_path, 'rb') as cert_file:\n                    cert_data = cert_file.read()\n                cert = OpenSSL.crypto.load_certificate(OpenSSL.crypto.FILETYPE_PEM, cert_data)\n                \n                # Check expiry date\n                not_after = datetime.datetime.strptime(\n                    cert.get_notAfter().decode('ascii'), '%Y%m%d%H%M%SZ'\n                )\n                days_until_expiry = (not_after - datetime.datetime.utcnow()).days\n                \n                if days_until_expiry < 30:\n                    self.errors.append(f\"SSL certificate expires in {days_until_expiry} days\")\n                elif days_until_expiry < 60:\n                    self.warnings.append(f\"SSL certificate expires in {days_until_expiry} days\")\n                else:\n                    logger.info(f\"SSL certificate valid for {days_until_expiry} days\")\n                    \n            except ImportError:\n                self.warnings.append(\"pyOpenSSL not available - cannot validate certificate expiry\")\n            \n        except Exception as e:\n            self.warnings.append(f\"SSL certificate validation failed: {str(e)}\")\n    \n    def _validate_production_runtime_requirements(self):\n        \"\"\"Production-specific runtime validation.\"\"\"\n        # Check that debug mode is disabled\n        debug = os.getenv('DEBUG', '').lower()\n        if debug in ('true', '1', 'yes'):\n            self.errors.append(\"DEBUG mode must be disabled in production\")\n        \n        # Check security settings\n        security_settings = {\n            'SESSION_COOKIE_SECURE': True,\n            'CSRF_COOKIE_SECURE': True,\n            'SECURE_SSL_REDIRECT': True,\n        }\n        \n        for setting, required_value in security_settings.items():\n            value = os.getenv(setting, '').lower()\n            if value not in ('true', '1', 'yes'):\n                self.errors.append(f\"{setting} must be enabled for production\")\n        \n        # Check monitoring configuration\n        if not os.getenv('SENTRY_DSN'):\n            self.warnings.append(\"SENTRY_DSN not configured - error tracking recommended for production\")\n        \n        # Check backup configuration\n        if not os.getenv('BACKUP_S3_BUCKET'):\n            self.warnings.append(\"Backup configuration not complete - recommended for production\")\n    \n    def _get_timestamp(self) -> str:\n        \"\"\"Get current timestamp in ISO format.\"\"\"\n        from datetime import datetime\n        return datetime.utcnow().isoformat() + 'Z'\n\n\nasync def validate_runtime_environment(environment: str = None) -> Dict[str, Any]:\n    \"\"\"\n    Validate runtime environment configuration.\n    \n    Args:\n        environment: Target environment (development, staging, production)\n        \n    Returns:\n        Validation results dictionary\n        \n    Raises:\n        EnvironmentValidationError: If validation fails for production\n    \"\"\"\n    validator = RuntimeValidator(environment)\n    return await validator.validate_all()\n\n\ndef main():\n    \"\"\"CLI entry point for runtime validation.\"\"\"\n    import argparse\n    \n    parser = argparse.ArgumentParser(description='Validate TidyFrame runtime environment')\n    parser.add_argument('--env', choices=['development', 'staging', 'production'], \n                       help='Target environment')\n    parser.add_argument('--strict', action='store_true', \n                       help='Treat warnings as errors')\n    \n    args = parser.parse_args()\n    \n    async def run_validation():\n        try:\n            results = await validate_runtime_environment(args.env)\n            \n            print(f\"\\n🔍 Runtime Validation Results\")\n            print(f\"Environment: {results['environment']}\")\n            print(f\"Timestamp: {results['timestamp']}\")\n            \n            if results['errors']:\n                print(f\"\\n❌ Errors ({len(results['errors'])}):\")\n                for error in results['errors']:\n                    print(f\"  • {error}\")\n                    \n            if results['warnings']:\n                print(f\"\\n⚠️  Warnings ({len(results['warnings'])}):\") \n                for warning in results['warnings']:\n                    print(f\"  • {warning}\")\n                    \n            if results['valid'] and not (args.strict and results['warnings']):\n                print(f\"\\n✅ Runtime validation passed!\")\n                sys.exit(0)\n            else:\n                print(f\"\\n❌ Runtime validation failed!\")\n                sys.exit(1)\n                \n        except Exception as e:\n            print(f\"\\n💥 Validation error: {str(e)}\")\n            sys.exit(1)\n    \n    # Run async validation\n    asyncio.run(run_validation())\n\n\nif __name__ == '__main__':\n    main()"