name: Continuous Deployment

on:
  workflow_run:
    workflows: ["Continuous Integration"]
    types:
      - completed
    branches:
      - main
      - develop

env:
  DO_REGION: nyc3
  DO_SIZE: s-1vcpu-1gb
  DEPLOYMENT_TIMEOUT: 600

jobs:
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'develop'
    environment:
      name: staging
      url: https://staging.tidyframe.com
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Deploy to staging droplet
        run: |
          # Update staging deployment
          doctl compute droplet-action reboot ${{ secrets.STAGING_DROPLET_ID }} --wait
          
          # Deploy with docker-compose
          doctl compute ssh ${{ secrets.STAGING_DROPLET_ID }} --ssh-command "
            cd /opt/app &&
            git pull origin develop &&
            docker-compose -f docker-compose.prod.yml pull &&
            docker-compose -f docker-compose.prod.yml up -d --remove-orphans
          "

      - name: Run health check
        run: |
          echo "Waiting for staging deployment to be ready..."
          for i in {1..30}; do
            if curl -f https://staging.tidyframe.com/health; then
              echo "‚úÖ Staging deployment successful"
              break
            fi
            echo "Waiting... ($i/30)"
            sleep 10
          done

      - name: Run smoke tests
        run: |
          curl -f https://staging.tidyframe.com/api/health
          curl -f https://staging.tidyframe.com/health

  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    if: github.event.workflow_run.conclusion == 'success' && github.event.workflow_run.head_branch == 'main'
    environment:
      name: production
      url: https://tidyframe.com
    needs: []
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Create deployment snapshot
        id: snapshot
        run: |
          SNAPSHOT_NAME="pre-deploy-$(date +%Y%m%d-%H%M%S)"
          doctl compute droplet-action snapshot ${{ secrets.PROD_DROPLET_ID }} --snapshot-name "$SNAPSHOT_NAME" --wait
          echo "snapshot_name=$SNAPSHOT_NAME" >> $GITHUB_OUTPUT

      - name: Blue-Green Deployment Setup
        id: blue-green
        run: |
          # Check current active environment
          CURRENT_ENV=$(doctl compute droplet get ${{ secrets.PROD_DROPLET_ID }} --format Tags --no-header | grep -o 'env:[^,]*' | cut -d: -f2 || echo "blue")
          
          if [ "$CURRENT_ENV" = "blue" ]; then
            NEW_ENV="green"
            INACTIVE_DROPLET_ID="${{ secrets.PROD_GREEN_DROPLET_ID }}"
            ACTIVE_DROPLET_ID="${{ secrets.PROD_BLUE_DROPLET_ID }}"
          else
            NEW_ENV="blue"
            INACTIVE_DROPLET_ID="${{ secrets.PROD_BLUE_DROPLET_ID }}"
            ACTIVE_DROPLET_ID="${{ secrets.PROD_GREEN_DROPLET_ID }}"
          fi
          
          echo "current_env=$CURRENT_ENV" >> $GITHUB_OUTPUT
          echo "new_env=$NEW_ENV" >> $GITHUB_OUTPUT
          echo "inactive_droplet_id=$INACTIVE_DROPLET_ID" >> $GITHUB_OUTPUT
          echo "active_droplet_id=$ACTIVE_DROPLET_ID" >> $GITHUB_OUTPUT

      - name: Deploy to inactive environment
        run: |
          echo "Deploying to ${{ steps.blue-green.outputs.new_env }} environment (Droplet: ${{ steps.blue-green.outputs.inactive_droplet_id }})"
          
          # Ensure inactive droplet is running
          doctl compute droplet-action power-on ${{ steps.blue-green.outputs.inactive_droplet_id }} --wait || true
          
          # Deploy new version to inactive environment
          doctl compute ssh ${{ steps.blue-green.outputs.inactive_droplet_id }} --ssh-command "
            cd /opt/app &&
            git fetch origin &&
            git reset --hard origin/main &&
            docker-compose -f docker-compose.prod.yml pull &&
            docker-compose -f docker-compose.prod.yml up -d --remove-orphans
          "

      - name: Health check new deployment
        id: health-check
        run: |
          INACTIVE_IP=$(doctl compute droplet get ${{ steps.blue-green.outputs.inactive_droplet_id }} --format PublicIPv4 --no-header)
          
          echo "Running health checks on new deployment ($INACTIVE_IP)..."
          HEALTH_CHECK_PASSED=false
          
          for i in {1..30}; do
            if curl -f -m 10 http://$INACTIVE_IP:8000/api/health && curl -f -m 10 http://$INACTIVE_IP:3000/health; then
              echo "‚úÖ Health check passed"
              HEALTH_CHECK_PASSED=true
              break
            fi
            echo "Health check failed, retrying... ($i/30)"
            sleep 10
          done
          
          if [ "$HEALTH_CHECK_PASSED" = "false" ]; then
            echo "‚ùå Health check failed"
            exit 1
          fi
          
          echo "inactive_ip=$INACTIVE_IP" >> $GITHUB_OUTPUT

      - name: Switch load balancer traffic
        run: |
          echo "Switching traffic to ${{ steps.blue-green.outputs.new_env }} environment..."
          
          # Update load balancer to point to new environment
          doctl compute load-balancer add-droplets ${{ secrets.LOAD_BALANCER_ID }} --droplet-ids ${{ steps.blue-green.outputs.inactive_droplet_id }}
          
          # Wait for load balancer to update
          sleep 30
          
          # Remove old environment from load balancer
          doctl compute load-balancer remove-droplets ${{ secrets.LOAD_BALANCER_ID }} --droplet-ids ${{ steps.blue-green.outputs.active_droplet_id }}

      - name: Verify production deployment
        run: |
          echo "Verifying production deployment..."
          
          for i in {1..20}; do
            if curl -f https://tidyframe.com/health && curl -f https://tidyframe.com/api/health; then
              echo "‚úÖ Production verification successful"
              break
            fi
            echo "Verification failed, retrying... ($i/20)"
            sleep 15
          done

      - name: Update environment tags
        run: |
          # Tag the new active environment
          doctl compute droplet tag ${{ steps.blue-green.outputs.inactive_droplet_id }} --tag-names "env:active,${{ steps.blue-green.outputs.new_env }}"
          
          # Tag the old environment as inactive
          doctl compute droplet untag ${{ steps.blue-green.outputs.active_droplet_id }} --tag-names "env:active"
          doctl compute droplet tag ${{ steps.blue-green.outputs.active_droplet_id }} --tag-names "env:inactive"

      - name: Notify deployment success
        uses: 8398a7/action-slack@v3
        with:
          status: success
          channel: '#deployments'
          text: 'üöÄ Production deployment successful! Environment switched to ${{ steps.blue-green.outputs.new_env }}'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  rollback-production:
    name: Rollback Production
    runs-on: ubuntu-latest
    if: failure() && github.event.workflow_run.head_branch == 'main'
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Determine rollback environment
        id: rollback
        run: |
          # Find the currently inactive environment (previous version)
          BLUE_ACTIVE=$(doctl compute droplet get ${{ secrets.PROD_BLUE_DROPLET_ID }} --format Tags --no-header | grep -q 'env:active' && echo "true" || echo "false")
          
          if [ "$BLUE_ACTIVE" = "true" ]; then
            ROLLBACK_DROPLET_ID="${{ secrets.PROD_GREEN_DROPLET_ID }}"
            CURRENT_DROPLET_ID="${{ secrets.PROD_BLUE_DROPLET_ID }}"
          else
            ROLLBACK_DROPLET_ID="${{ secrets.PROD_BLUE_DROPLET_ID }}"
            CURRENT_DROPLET_ID="${{ secrets.PROD_GREEN_DROPLET_ID }}"
          fi
          
          echo "rollback_droplet_id=$ROLLBACK_DROPLET_ID" >> $GITHUB_OUTPUT
          echo "current_droplet_id=$CURRENT_DROPLET_ID" >> $GITHUB_OUTPUT

      - name: Switch back to previous environment
        run: |
          echo "Rolling back to previous environment..."
          
          # Add previous environment back to load balancer
          doctl compute load-balancer add-droplets ${{ secrets.LOAD_BALANCER_ID }} --droplet-ids ${{ steps.rollback.outputs.rollback_droplet_id }}
          
          sleep 30
          
          # Remove failed deployment from load balancer
          doctl compute load-balancer remove-droplets ${{ secrets.LOAD_BALANCER_ID }} --droplet-ids ${{ steps.rollback.outputs.current_droplet_id }}

      - name: Verify rollback
        run: |
          echo "Verifying rollback..."
          
          for i in {1..10}; do
            if curl -f https://tidyframe.com/health; then
              echo "‚úÖ Rollback successful"
              break
            fi
            echo "Rollback verification failed, retrying... ($i/10)"
            sleep 10
          done

      - name: Notify rollback
        uses: 8398a7/action-slack@v3
        with:
          status: failure
          channel: '#deployments'
          text: '‚ö†Ô∏è Production deployment failed and was rolled back!'
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}

  cleanup-old-images:
    name: Cleanup Old Images
    runs-on: ubuntu-latest
    if: always()
    needs: [deploy-production]
    steps:
      - name: Install doctl
        uses: digitalocean/action-doctl@v2
        with:
          token: ${{ secrets.DIGITALOCEAN_ACCESS_TOKEN }}

      - name: Cleanup old container images
        run: |
          # Keep only the last 10 images for each repository
          for repo in frontend backend; do
            echo "Cleaning up old images for $repo..."
            doctl registry repository list-tags ${{ secrets.DO_REGISTRY_NAME }}/$repo --format Tag,UpdatedAt | \
              tail -n +11 | \
              awk '{print $1}' | \
              xargs -r -I {} doctl registry repository delete-tag ${{ secrets.DO_REGISTRY_NAME }}/$repo {} --force
          done

      - name: Run garbage collection
        run: |
          doctl registry garbage-collection start ${{ secrets.DO_REGISTRY_NAME }} --include-untagged-manifests